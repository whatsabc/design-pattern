## 1 策略模式

现在有一个鸭子类：

```java
class Duck{
	quack();
	swim();
	fly();
	//其他方法
}
```

我们把Duck类的fly()和quack()会随着鸭子的不同而改变，为了要把这两个行为从Duck类中分开，我们将把它们从Duck类中取出来，建立一组新类来代表每个行为。

为了能在“运行时”动态地“改变”对象的行为，为了实现这个目标，我们需要以下设计原则;

> 针对接口编程，而不是针对实现编程，我们利用接口代表每个行为，比方说，FlyBehavior与 QuackBehavior，而行为的每个实现都将实现其中的一个接口。

“针对接口编程”真正的意思是“针对超类型（supertype）编程”

这里所谓的“接口”有多个含义，接口是一个“概念”，也是一种Java的interface构造。你可以在不涉及Java interface的情况下，“针对接口编程”，关键就在多态。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为，不会被绑死在超类型的行为上。“针对超类型编程”这句话，可以更明确地说成“变量的声明类型应该是超类型，通常是一个抽象类或者是个接口，如此，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这也意味着，声明类时不用理会以后执行时的真正对象类型！

这可能不是你第一次听到，但是请务必注意我们说的是同件事。看看下面这个简单的多态例子：假设有一个抽象类 Animal，有两个具体的实现（Dog与cat）继承 Animal.做法如下

“针对实现编程

```java
Dog d =new Dog();
d.bark();
```

但是，“针对接口/超类型编程”做法会如下

```java
Animal animal=new Dog();
animal.make Sound();
```

更棒的是，子类实例化的动作不再需要在代码中硬编码，例如new Dog()，而是“在运行时才指定具体实现的对象

```java
a=getAnimal();
a.makeSound();
```

我们可以给上面的两个行为接口实现具体的行为。

下面是具体实例代码;

实现FlyBehavio接囗与两个行为实现

```java
public interface FlyBehavior {
	public void fly();
}
```

```java
public class FlywithWings implements FlyBehavior {
	public void fly(){
		System.out.println("I'm flying");
	}
}
```

```java
public class FlyNoWay implements FlyBehavior{
	public void fly() {
		System.out. println("I can't fly");
	}
}
```

QuackBehavior接口及其三个实现类

```java
public interface QuackBehavior {
	public void quack();
}
```

```java
public class Quack implements QuackBehavior {
	public void quack() {
		System.out.println("Quack");
	}
}
```

```
public class MuteQuack implements QuackBehavior {
	public void quack() {
		System.out.println("<< Silence >>");
	}
}
```

```java
public class Squeak implements QuackBehavior {
	public void quack() {
		System.out.printIn("Squeak");
	}
}
```

Duck类

```java
public abstract class Duck {
	FlyBehavior flyBehavior;
	QuackBehavior quackBehavior;
	public Duck(){
	
	}
	
	public abstract void display();
	
	public void performFly(){
		flyBehavior.fly();
	}
	
	public void performQuack(){
		quackBehavior.quack();
	}
	
	public void swim(){
		System.out.println("All ducks float,even decoys!");
	}	
}
```

输入并编译测试类( MiniDuckSimulator.java)

```java
public class MiniDuckSimulator {
	public static void main(String [] args) {
		Duck mallard= new MallardDuck();
		mallard.performQuack();
		mallard.performFly();
	}
}
```

动态设定行为

假设我们想在鸭子子类中通过“设定方法”来设定鸭子的行为，而不是在鸭子的构造器内实例化

Duck类中，加入两个新方法

```java
public void setFlyBehavior (FlyBehavior fb) {
	flyBehavior=fb;
}
public void setquackBehavior (QuackBehavior qb) {
	quackBehavior=qb;
}
```

制造一个新的鸭子类型:模型鸭ModelDuck.java

```java
public class ModelDuck extends Duck {
	public ModelDuck() {
		flyBehavior = new FlyNoWay();//刚开始我们的模型鸭子不会飞
		quackBehavior = new Quack();
	}
		
	public void display(){
		System.out.println("I'm a model duck");
	}
}
```

建立一个新的 FlyBehavior类型FlyRocketPowered.java

```java
//我们建立一个利用火箭动力的飞行行为
public class FlyRocketPowered implements FlyBehavior{
	public void fly() {
		System.out.println("I'm flying with a rocket!");
	}
}
```

改变测试类，并使之具有火箭动力

```java
public class MiniDucksimulator {
	public static void main(String[] args) {
		Duck mallard = new MallardDuck ();
		mallard.performQuack();
		mallard.performFly();
		Duck model = new ModelDuck();
		model.performFly();
		model.setFlyBehavior(new FlyRocketPowered());
		model.performFly();
	}
}
```

> 策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

## 2 观察者模式

现在有一个类WeatherData

```java
class WeatherData{
	下面三个方法各自返回最近的气象测量数据
	getTemperature();
	getHumidity();
	getPressure();
	//新的数据准备妥当时，这个方法就会被调用，我们只需要在乎它被调用了
	measurementsChanged();
	//其他的方法
}
```

现在我们需要实现显示三个使用天气数据的布告板。

> 观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

**松耦合**

当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。

关于观察者的一切，主题只知道观察者实现了某个接口（也就是 Observer接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。

任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在任何时候删除某些观察者。

有新类型的观察者出现时，主题的代码不需要修改。假如我们有个新的具体类需要当观察者，我们不需要为了兼容新类型而修改主题的代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。

我们可以独立地复用主题或观察者。如果我们在其他地方需要使用主題或观察者，可以轻易地复用，因为二者并非紧耦合。

改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由地改变他们。

首先，我们准备三个接口

```java
public interface Subject{
	public void registerobserver(observer o);
	public void removeObserver(observer o);
	public void notifyobservers();
}
```

```java
public interface observer{
	public void update (float temp,float humidity,float pressure);
}
```

```java
public interface DisplayElement{
	public void display();
}
```

在WeatherData中实现主题接口

```java
public class WeatherData implements Subject {
	private ArrayList observers;
	private float temperatu;
	private float humidity;
	private float pressure;
	
	public WeatherData(){
		observers = new ArrayList();
	}
	
	public void registerobserver(Observer o){
		observers.add(o);
	}
	
	public void removeObserver(observer o) {
		int i = observers indexof(o);
		if(i>=0){
			observers.remove(i);
		}
	}

	public void notifyobservers() {
		for (int i=0; i < observers.size(); i++) {
			Observer observer =(observer)observers.get(i);
			observer.update(temperature,humidity,pressure);
		}
   }

	public void measurementschanged(){
        notifyobservers();
    }

	public void setMeasurements(float temperature,float humidityity,float pressure) {
		this.temperature = temperature;
		this.humidity = humidity;

		this.pressure = pressure;
		measurementschanged();
    }
    // WeatherData的其他方法
}
```

下面是设计的一个布告板

```java
public class CurrentConditionsDisplay implements Observer, DisplayElement {
	private float temperature;
	private foat humidity;
	private Subject weatherData;
    
    //构造器需要weatherData对象（也就是主题）作为注册之用
	public Currentconditions Display(Subject weatherDate) {
		this.weatherData = weatherData;
		weatherData.registerObserver(this);
	}

	public void update(float temperature, float humidity, float pressure){
		this.temperature = temperature;
		this.humidity = humidity;//当update被调用时，我们把温度和适度保存起来，然后调用diaplay()显示它们
		display();
    }

	public void display() {
		System. out. println("Current conditions: "+temperature +"F degrees and" + humidity + "% humidity");
    }
}
```

完成气象站，建立一个测试程序：

```java
public class WeatherStation {
	public static void main(String [] args) {
		WeatherData weatherData new weather Data();
		CurrentconditionsDisplay currentDisplay=new CurrentConditionsDisplay(weatherData);
		StatisticsDisplay statisticsDisplay = new statisticsDisplay(weatherData);
		ForecastDisplay forecastDisplay= new ForecastDisplay(weatherData);
		
		weatherData.setMeasurements(80,65,30.4f);
		weatherData.setMeasurements(82,70,29.2f);
		weatherData.setMeasurements(78,90,29.2f);
	}
}
```

## 3 装饰者模式

**开放-关闭原则**

类应该对扩展开放，对修改关闭。

比如之前的观察者模式，通过加入新的观察者，我们可以在任何时候扩展主题，而且不需要向主题中添加代码。

我们的目标是允许类容易扩展，在不修改现有代码的情况新的行为。如能实现这样的目标，有什么好处呢？这样的设计具有弹性可以应对改变，可以接受新的功能来应对改变的需求。

> 装饰者模式
>
> 动态地将责任附加在对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

下面我们以咖啡店的咖啡为例来讲解装饰者模式

首先定义一个Beverage类

```java
public abstract class Beverage {
	String description="Unknown Beverage";
	
	public String getDescription() {
		return description;
	}
	
	public abstract double cost();
}
```

然后定义一个调料抽象类

```java
public abstract class CondimentDecorator extends Beverage {
	public abstract string getDescription();
}
```

下面开始写饮料的代码

```java
public class Espresso extends Beverage {
	public Espresso(){
		description = "Espresso";
	}

	public double cost() {
		return 1.99;
	}
}
```



```java
public class HouseBlend extends Beverage {
	public HouseBlend() {
		description ="House Blend Coffee";
	}

	public double cost() {
		return .89;
	}
}
```

**写调料的代码**

之前，我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：

```java
public class Mocha extends CondimentDecorator{
	Beverage beverage;//被装饰者

	public Mocha(Beverage beverage){
		this.beverage = beverage;//让被装饰者被记录到实例变量中
	}

	public String getDescription(){
		return beverage.getDescription()+", Mocha";
	}

	public double cost() {
		return .20 + beverage cost();
	}
}
```

下面测试

```java
public class StarbuzzCoffee {
	public static void main(String args[]) {
		Beverage beverage = new Espresso();
		System.out.println(beverage.getDescription()+" $"+ beverage cost());
		Beverage beverage2= new DarkRoast();
		beverage2 = new Mocha(beverage2);
		beverage2 = new Mocha(beverage2);
		beverage2 = new Whip(beverage2);

		System.out.printIn(beverage.getDescription()+" $"+ beverage.cost());
		Beverage beverage3= new HouseBlend();
		beverage3 = new Soy(beverage);
		beverage3 = new Mocha(beverage);
		beverage3 = new Whip(beverage);
		System.out.println(beverage getDescription()+" $"+ beverage.cost());
	}
}
```

## 4 工厂模式

除了使用new操作符之外，还有更多制造对象的方法。

当使用new时，我们的确是在实例化一个具体类，所以用的确实是实现，而不是接口。代码绑着具体实现类会导致代码更脆弱，更缺乏弹性。

```java
Duck duck;

if (picnic) {
	duck = new MallardDuck ();
} else if (hunting)(
	duck = new DecoyDuck ();
}else if (inBathTub) {
	duck = new RubberDuck();
}
```

对于这种代码，一旦有变化或者扩展，就必须重新打开这段代码进行检查和修改。通常这样修改过的代码将造成部分系统更难维护和更新，通常也更容易犯错。

下面是一个比萨店的例子

```java
Pizza orderpizza() {
	Pizza pizza=new Pizza();
	pizza.prepare();
	pizza.bake ();
	Pizza.cut ();
	pizza box();
	return pizza;
}
```

假如需要更多的披萨类型

```java
Pizza orderPizza(String type){
	Pizza pizza;
	if(type.equal("cheese")){
		pizza=new CheesePizza();
	} else if(type.equal("greek")){
		pizza=new GreekPizza();
	} else if(type.equal("pepperoni")){
		pizza=new PepperoniPizza();
	}
	
	pizza.prepare();
	pizza.bake ();
	Pizza.cut ();
	pizza.box();
	return pizza;
}
```

加入比萨类型增多。那么上面的if判断就要修改并会变得及其复杂，而下面的披萨的做法并不会改变。很明显，如果实例化某些具体类，orderPizza()无法对修改关闭，既然知道了那些会改变，哪些不会改变，那么我们可以使用封装。

我们把创建对象移到orderPizza()方法之外，由一个新对象专职创建披萨，我们称这个新对象为**工厂**，工厂处理创建对象的细节。现在orderPizza()方法只需要关心从工厂得到了一个披萨，而这个披萨实现了Pizza接口，所以它可以调用各种方法来分别进行披萨的制造。

下面是一个简单披萨工厂

```java
public class simplePizzaFactory {
	public Pizza createPizza(string type) {
		Pizza pizza= null;
		
		if (type.equals("cheese")){
			pizza = new CheesePizza();
		}
		else if (type.equals("pepperoni")){
			pizza = new PepperoniPizza();
		}
		else if (type.equals("clam" )){
			pizza = new ClamPizza();
		}
		else if (type.equals("veggie")) {
			pizza = new VeggiePizza();
		}
		return pizza;
    }
}
```

重做PizzaStore类

```java
public class PizzaStore{
	SimplePizzaFactory factory;
	
	public PizzaStore(SimplePizzaFactory factory){
		this.factory=factory;
	}
	
	public Pizza orderpizza(String type) {
		Pizza pizza=factory.createPizza(type);
		pizza.prepare();
		pizza.bake ();
		Pizza.cut ();
		pizza box();
		return pizza;
	}
	//其他方法
}
```

其实简单工厂并不是一个设计模式，更像是一种编程习惯。

下面我们继续拓展我们的披萨店

如果披萨店有了众多加盟店，而且这些加盟店位于不同的地区，披萨口味都不同，按照之前的简单工厂模式，我们的代码应该如下

我们接着建立两个不同的工厂NYPizzaFactory和ChicagoPizzaFactory

```java
PizzaFactory nyFactory = new NYPizzaFactory();
Pizzastoreny Store = new PizzaStore(nyFactory);
nyStore.orderPizza("Veggie");
```

```java
ChicagoPizzaFactory chicagoFactory = new ChicagoPizzaFactory();
Pizzastore chicagostore = new Pizzastore(chicagoFactory);
chicagostore.orderPizza("Veggie");
```

假如我们需要对披萨店实施质量控制，在其他部分，流程都与总店一样，那么，我们需要建立一个框架。将加盟店和创建披萨捆绑在一起的同时又保持一定的弹性。

为此，我们将createPizza()方法重新放回到PizzaStore中，不过要把它设置为抽象方法。

```java
public abstract class Pizzastore {
	public Pizza orderPizza(String type) {
		Pizza pizza;
        
		pizza = createPizza(type);
        
		pizza.prepare();
		pizza.bake();
		piZza.cut();
		pizza.box();
        
		return pizza;
    }
    
	abstract Pizza createPizza (string type);
}
```

然后让每个子店继承这个超类。现在我们的所有店铺的处理订单的方式都一致，不同的则是制作的口味。

现在我们实例化一个比萨加盟店

```java
public class NYPizzaStore extends PizzaStore {
	Pizza createPizza(string item) {
		if (item.equals("cheese")) {
			return new NYStylecheesepizza();
        } else if (item.equals("veggie")) {
			return new NYStyleveggiePizza();
		}else if (item.equals("clam")) {
			return new NYStyleclamPizza();
		}else if (item.equals("pepperoni")) {
			return new NYStylePepperoniPizza();
		} else return null;
    }
}
```

超类的orderPizza()方法，并不知道正在创建的披萨是哪一种，只需要知道这个披萨可以被准备，被烘烤...

现在准备一个披萨抽象类

```java
public abstract class Pizza {
	string name;
	String dough;
	String sauce;
	ArrayList toppings = new ArrayList();

	void prepare() {
		System.out.println("Preparing" + name);
		System.out.printIn("Tossing dough");
		System.out.println("Adding sauce");
		System.out.println("Adding toppings: );
		for (int i=0; i< toppings.size(); i++) {
			system.out.println("  " + toppings.get(i));
		}
	}

	void bake() {
		System.out.println("Bake for 25 minutes at 350);
	}
	void cut() {
		System.out.printin("Cutting the pizza into diagonal slices");
	}
	void box() {
		System.out.println("Place pizza in official Pizzastore box");
	}
	public String getName() {
		return name;
	}
}
```

然后构造一些具体的子类

```java
public class NYStyleCheesePizza extends Pizza {
	public NYStylecheesePizza() {
		name = "NY style Sauce and Cheese pizza";
		dough = "Thin Crust Dough";
		sauce = "Marinara Sauce";
		toppings.add("Grated Reggiano Cheese");
	}
}
```

```java
public class ChicagostyleCheesePizza extends Pizza {
	public chicagostyleCheesePizza() {
		name = "Chicago Style Deep Dish Cheese Pizza";
		dough = "Extra Thick Crust Dough";
		sauce = "Plum Tomato sauce";
		toppings.add("Shredded Mozzarella Cheese");
    }

	void cut(){
		system.out.println("Cutting the pizza into square slic");
    }
}
```

现在需要点一些披萨，看一下点披萨的具体流程是什么：

1. 首先需要一个披萨店

```java
PizzaStore nyPizzaStore = new NYPizzaStore();
```

2. 然后下订单，调用nyPizzaStore实例中的orderPizza()方法

```java
nyPizzaStore.orderPizza("cheese");
```

3. orderPizza()方法调用createPizza()方法

```java
Pizza pizza = createPizza("cheese");
```

4. 经过如下处理完成orderPizza()：

```java
pizza.prepare();
pizza.bake();
...
```

**工厂模式总述**

有两大类：

> **创建者类**
>
> 如实例中的PizzaStore抽象创建者类，定义了一个抽象的工厂方法，让子类实现此方法制造产品
>
> ```java
> class PizzaStore {
> 	createPizza();
> 	orderPizza();
> }
> ```
>
> 创建者通常会把包含依赖于抽象产品的代码，而这些抽象产品由于子类制造，创建者不需要真的知道在制造哪种具体产品
>
> 能够生产产品的类成为具体创建者
>
> ```java
> class NYPizzaStore extends PizzaStore{
> 	createPizza();
> }
> ```
>
> ```java
> class ChicagoPizzaStore extends PizzaStore{
> 	createPizza();
> }
> ```
>
> **产品类**
>
> 工厂生产产品，对PizzaStore来说，产品就是Pizza
>
> ```
> Pizza
> ```
>
> 每个店铺的所有产品都可以继承这个超类实现

**对于简单工厂和工厂方法之间的差异**

子类的确看起来很像简单工厂。简单工厂把全部的事情，在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现，比方说，在工厂方法中， orderPizza()方法提供了一般的框架，以便创建比萨， orderPizza()方法依赖工厂方法创建具体类，并制造出实际的比萨。可通过继承 Pizzastore()类，决定实际制造出的比萨是什么。简单工厂的做法，可以将对象的创建封装起来，但是简单工厂不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。

**依赖倒置原则**

代码里需要减少对具体类的依赖，这个原则叫“依赖倒置原则”。

> 依赖倒置原则
>
> 要依赖抽象，不要依赖具体类

这个原则听起来与针对接口编程很相似，但是这里更加强调抽象，不能让高层组件依赖底层组件，而且，不管高层或底层组件，两者都应该依赖于抽象。

比如上例中的PizzaStore是高层组件，披萨实现是底层组件。

在上面的例子中，在应用了工厂方法后，Pizza是一个抽象，PizzaStore（高层组件）依赖这个抽象类，具体披萨实现类也依赖Pizza（底层组件）抽象，因为它们实现了Pizza接口（广义的接口定义）。

现在我们还需要扩展我们的披萨店：

我们要保证所有的加盟店使用的都是统一的高质量原料，我们需要建造一个原料工厂，首先我们先为工厂定义一个接口，这个几口负责创建所有的原料：

```java
public interface PizzaIngredientFactory {
	public Dough createDough();
	public Sauce createSauce();
	public Cheese createCheese();
	public Veggies[] createVeggies();
	public Pepperoni createPepperoni();
	public Clams createClam();
}
```

接下来我们创建一个具体的工厂

```java
public class NYPizzaIngredientFactory implements PizzaIngredientFactory {
	public Dough createDough () {
		return new ThincrustDough();
	}

	public Sauce createSauce() {
		return new Marinarasauce();
    }

	public Cheese createcheese() {
		return new Reggiaeesecheese();
    }

	public Veggies[] createVeggies() {
		Veggiesveggies[]={ new Garlic(), new Onion(), new Mushroom(), new RedPepper() };
		return veggies;
    }

	public Pepperoni createPepperoni() {
		return new SlicedPepperoni();
    }

	public clams createClam() {
		return new Freshclams();
    }
}
```

重做披萨

```java
public abstract class Pizza {
	string name;
	String dough;
	String sauce;
	//要使用的原料
	Veggies veggies[];
	Cheese cheese;
	Pepperoni pepperoni;
	Clams clam;
	
	abstract void prepare();//我们收集所需要的原料，这些原料来自原料工厂
	
	ArrayList toppings = new ArrayList();

	void prepare() {
		System.out.println("Preparing" + name);
		System.out.printIn("Tossing dough");
		System.out.println("Adding sauce");
		System.out.println("Adding toppings: );
		for (int i=0; i< toppings.size(); i++) {
			system.out.println("  " + toppings.get(i));
		}
	}

	void bake() {
		System.out.println("Bake for 25 minutes at 350);
	}
	void cut() {
		System.out.printin("Cutting the pizza into diagonal slices");
	}
	void box() {
		System.out.println("Place pizza in official Pizzastore box");
	}
	public String getName() {
		return name;
	}
	
	public String toString(){
		//这里是打印披萨的代码
	}
}
```

有了抽象类，我们可以创建具体的披萨种类。我们曾经写过工厂方法的代码，有NYCheesePizza和ChicagoPizza类。比较一下这两个类，唯一的差别在于使用区域性的原料，至于比萨的做法都一样（面团+酱料+芝士），其他的比萨（蔬菜、蛤蜊等）也是如此。它们都依循着相同的准备步骤，只是使用不同的原料。

所以，其实我们不需要设计两个不同的类来处理不同风味的比萨，让原料工厂处理这种区域差异就可以了。下面是CheesePizza

```java
public class CheesePizza extends Pizza {
	PizzaIngredientFactory ingredientFactory;
	
    //工厂为每个披萨方法提供原料
	public CheesePizza(PizzaIngredientFactory ingredientFactory {
		this.ingredientFactory = ingredientFactory;
	}
	
	void prepare() {
		System.out.println("Preparing"+ name);
		dough = ingredientFactory.createDough();
		sauce = ingredientFactory.createsauce();
		cheese = ingredientFactory.createcheese();
	}
}
```

再准备披萨店

```java
public class NYPizzaStore extends PizzaStore {
	protected Pizza createPizza(string item) {
		Pizza pizza=null;
		PizzaIngredientFactory ingredientFactory= new NYPizzaIngredientFactory();
		
		if (item.equals("cheese")) {
			//对于某一种披萨，我们实例化一个新的披萨，并传进这种披萨所需要的工厂，以便取得原料
			pizza = new CheesePizza(ingredientFactory);
			pizza.setName("New York Style Cheesse Pizza");
			
        } else if (item.equals("veggie")) {
			pizza = new VeggiePizza(ingredientFactory);
			pizza.setName("New York Style Veggie Pizza");
			
		}else if (item.equals("clam")) {
			pizza = new ClamPizza(ingredientFactory);
			pizza.setName("New York Style Clam Pizza");
			
		}else if (item.equals("pepperoni")) {
			pizza = new PepperoniPizza(ingredientFactory);
			pizza.setName("New York Style Pepperoni Pizza");
			
		} 
		return pizza;
    }
}
```

我们通过引入新类型的工厂，实现了从实际工厂解耦。

**定义抽象工厂模式**

> 抽象工厂模式
>
> 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

## 5 单例模式

独一无二的，只有一个实例的对象

经典的单件模式实现

```java
public class Singleton{
	private static Singleton uniqueInstance;
	
	private Singleton() {}
	public static Singleton getInstance() {
		if(uniqueInstance==null){
            uniqueInstance=new Singleton();
		}
		return uniqueInstance;
	}
}
```

> 单件模式
>
> 确保一个类只有一个实例，并提供一个全局访问点

##  7 适配器与外观模式

现在有一个鸭子类

```java
public interface Duck {
	public void quack();
	public void fly();
}
```

绿头鸭是鸭子的子类

```java
public class MallardDuck implements Duck {
	public void quack() {
		System.out.println("Quack");
	}
	public void fly(){
		System.out.println("I'm flying");
	}
}
```

火鸡

```java
public interface Turkey {
	public void gobble();
	public void fly();
}
```

火鸡的实现

```java
public class WildTurkey implements Turkey {
	public void gobble() {
		System.out.println("Gobble gobble");
	}
	public void fly() {
		System.out.println("I'm flying a short distance");
	}
}
```

加入现在缺鸭子对象，要用一些火鸡对象来冒充，我们就需要一个适配器：

```java
public class TurkeyAdapter implements Duck {
	Turkey turkey;
	//构造器获取要适配对象的引用
	public TurkeyAdapter(Turkey turkey){
		this.turkey=turkey;
	}
	
	public void quack(){
		turkey.gobble();
	}
	
	public void fly(){
		for(int i=0;i<5;i++){
			turkey.fly();
		}
	}
}
```

测试适配器

```java
public class DuckTestDrive {
	public static void main(String[] args) {
		Mallardduck duck = new MallardDuck();
		
		wildTurkey turkey = new wildTurkey();
		Duck turkeyAdapter = new TurkeyAdapter(turkey);

		System.out.println("The Turkey says.");
		turkey.gobble();

		System.out.println("\nThe Duck says.");
		testDuck(duck);

		System.out.println("\nThe TurkeyAdapter says.. ");
		testDuck(turkeyAdapter);
	}

	static void testDuck(Duck duck) {
		duck.quack();
		duck.fly();
    }
}
```

测试结果

```
% java DuckTestDrive
The Turkey says...
Gobble gobble
I'm flying a short distance

The Duck says...
Quack
I' m flying

The TurkeyAdapter says...
Gobble gobble
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
I'm flying a short distance
```

**一个适配器只能封装一个类吗？**

适配器模式的工作是将一个接口转换成另一个。虽然大多数的适配器模式所采取的例子都是让一个适配器包装一个被适配者，但是这个世界其实复杂多了，所以你可能遇到一些状况，需要让一个适配器包装多个被适配者。

这涉及另一个模式，被称为外观模式（ Facade Pattern），下面会详细解释

**一些现在被广泛应用的适配器**

早期Java使用的枚举器

```java
public interface Enumeration{
	hasMoreElements();
	nextElement();
}
```

现在使用的迭代器Iterator接口

```java
public interface Iterator {
	hasNext();
	next();
	remove();
}
```

面对某些遗留代码暴露出来的枚举器接口，我们又希望在新的代码中只使用迭代器，这时我们就需要构造一个适配器。

**装饰者和适配器的区别和联系**

装饰者和适配器都是用来包装对象的，但是装饰者不会改变接口，知识扩展所包装的对象的行为或责任，而适配器则需要改变接口，这两者虽然在纸上看起来很类似，但是意图差距颇大。

下面这个例子将带领我们走向外观模式，外观模式改变接口的原因是为了简化接口，它将一个或数个类的复杂的一切都隐藏在背后，只露出一个干净美好的外观。

现在有一个家庭影院，内涵DVD，投影机，屏幕等等组件，这些组件被抽象成了一个个类，每个类下面都有若干方法，当你需要享受一部电影的时候，你就需要依次执行很多任务（打开xxx，打开xxx...）

我们将这些任务写出类和方法的调用

```
//一共涉及到了六个不同的类！！
popper.on();
popper.pop();

lights.dim(10);

screen.down();

projector.on();
projector.setInput(dvd);
projector.wideScreenMode();

amp.on();
amp.setDvd(dvd);
amp.setSurroundSound();
amp.setVolume(5);

dvd.on();
dvd.play(movie);
```

而结束看电影的时候同样要调用这么多的方法，如何简化这些操作呢？

我们首先创建了一个HomeTheaterFacade的新类

```
public class Home TheaterFacade {
	//我们用到的子系统组件全部在这儿
	Amplifier amp;
	Tuner tuner;
	DvdPlayer dvd;
	CdPlayer cd;
	Projector projector;
	TheaterLights lights;
	Screen screens;
	PopcornPopper popper;
	
	public Home Theater Facade(Amplifier amp,
			Tuner tuner,
			DvdPlayer dvd,
			CdPlayer cd,
			Projector projector,
			screen screen,
			TheaterLights lights,
			PopcornPopper popper) {
		this.amp = amp;
		this.tuner = tuner;
		this.cd = cd;
		this projector = projector;
		this screen = screen;
		this.lights = lights;
		this.popper =popper;
	}
	//其他方法
}
```

实现两个方法

```
public void watchMovie(string movie)[
	System.out.println("Get ready to watch a movie.");
	popper.on();
	popper.pop();
	lights.dim(10);
	screen.down();

	projector.on();

	projector.wideScreenMode();
	amp.on();
	amp.setDvd(dvd);
	amp.setSurroundSound();
	amp.setvolume(5);
	dvd.on();
	dvd.play(movie);
}
```

```
public void endMovie() {
	System.out.println("Shutting movie theater down..");
	popper.off();
	lights.on();
	screen.up();
	projector.off();
	amp.off();
	dvd.stop();
	dvd.eject();
	dvd.off();
}
```

用简单的方式观赏电影

```java
public class Home TheaterTest Drive {
	public static void main(String[] args) {

		HomeTheaterFacade homeTheater = new HomeTheaterFacade (amp, tuner, dvd, cd, projector, screen, lights, popper);
		home Theater.watchMovie("Raiders of the Lost Ark");
		home Theater.endMovie ();
    }
}
```

外观模式实际上是创建了一个接口简化而统一的类，用来包装子系统中一个或多个复杂的类。外观模式相当直接，更容易理解，这方面和许多其他的模式不太一样。

> 外观模式
>
> 提供了一个接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

下面是一个新的OO原则

> 最少知识原则
>
> 当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的
>
> 这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中一部分，会影响到其他部分。如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，他需要花许多成本维护，也会因为太复杂而不容易被其他人了解。

## 11 代理模式

> 代理模式
>
> 为另一个对象提供一个替身或占位符以控制对这个对象的访问

类图如下：

RealSubject和Proxy都实现了Subject接口

```java
interface Subject {
	request();
}
```

下面是一个真正做事的对象，Proxy会控制对RealSubject的访问

```
RealSubject
```

Proxy通常负责创建RealSubject对象，并持有Subject的引用，必要时可以将请求转发给Subject

```
Proxy
```

**虚拟代理**

下面是一个程序用来展示在线的CD封面，从网络上等待图像加载的时候，应该显示一些东西，一旦图像加载完毕，刚才现实的东西消失，图像显示出来。

下面是类图：

Swing的Icon接口

```java
interface Icon {
	getIconWidth();
	getIconHeight();
	paintIcon();
}
```

一个显示图像的类

```java
class Imageicon implements Icon {
	getIconWidth();
	getIconHeight();
	paintIcon();
}
```

代理类

```java
class ImageProxy implements Icon {
	getIconWidth();
	getIconHeight();
	paintIcon();
}
```

ImageProxy如何工作

1. ImageProxy首先创建一个ImageIcon，然后开始从网络加载图像
2. 加载过程中，ImageProxy显示”正在加载"
3. 加载完毕后，ImageProxy把所有方法调用委托给真正的ImageIcon，这些方法包括了上述所有方法
4. 如果新用户请求新的图像，就创建新的代理，重复这样的过程

先编写ImageProxy

```java
class Image Proxy implements Icon {
	ImageIcon imageIcon;
	URL imageURL;
	Thread retrievalThread;
	boolean retrieving = false;

	public ImageProxy (URL url) {
		imageURL = url;
	}

	public int getIconwidth() {
		if (imageIcon != null) {
			return imageIcon.getIconwidth();
		} else {
			return 800;
		}

	public int getIconHeight() {
		if (imageIcon != null) {
			return imageIcon.getIconHeight();
		} else {
			return 600;
		}
	}

	public void paintIcon (final Component c, Graphics g, int x, int y) {
		if(imageIcon!=null){
            imageIcon.printIcon(c,g,x,y);
        } else {
            g.drawString("Loading CD cover,please wait...",x+300,y+300);
            if(!retrieving){
                retrieving=true;
                //我们不希望挂起整个用户界面，所以用另一个线程取出图像
                retrievalThread =new Thread(new Runnable(){
                    public void run(){
                        try {
                            imageIcon = new ImageIcon(imageURL,"CD Cover");//构造器在图像加载后返回
                            c.repaint();//图像准备好之后告诉Swing进行重绘
                        } catch(Exception e){
                            e.printStackTrace();
                        }
                    }
                });
                retrievalThread.start();
            }
        }
    }
}
```

下面我们测试我们创建好的CD浏览器

```java
public class Image Proxy TestDrive {
	Imagecomponent imageComponent;
	public static void main (String[] args) throws Exception {
		ImageProxyTestDrive testDrive = new ImageProxyTestDrive ();
    }

	public Image ProxyTest Drive() throws Exception {

		Icon icon = new Image Proxy(initialURL);//创建图像代理，并指定初始URL
		image Component = new Imagecomponent(icon);//将代理包装进组件，使之能放入框架
		frame.getcontentPane().add(imagecomponent);//放入框架并显示
    }
}
```

> ImageProxy与装饰者有什么关系，他们基本上都是用一个对象把另一个包起来，然后把调用委托给ImageIcon
>
> 他们的目的是不一样的。装饰者为对象增加行为，而代理是控制对象的访问。d代理将客户与ImageIcon解耦了，如果它们之间没有解耦，客户就必须等到每幅画像都被取回，才能绘制在界面上，一旦ImageIcon被创建，代理就允许访问ImageIcon

> 代理和适配器的区别是什么
>
> 代理和适配器都是挡在其他对象的前面，并负责将请求转发给它们。适配器会改变对象适配的接口，而代理则实现相同的接口。有一个额外相似性牵涉到保护代理（ Protection Proxy）。保护代理可以根据客户的角色来决定是否允许客户访问特定的方法。所以保护代理可能只提供给客户部分接口，这就和某些适配器很相像了。再过几页，我们就会讨论到保护代理。

**动态代理**

与之前虚拟代理的类图不同的是，动态代理的代理类由两部分组成

Proxy由Java产生，而且实现了完整的Subject接口

```
Proxy
request();
```

Proxy的任何方法调用都会被传入InvocationHandler类，这个类控制对RealSubject方法的访问

```
InvocationHandler
invoke();
```

下面我们实现一个约会服务系统

首先实现一个Person bean，允许设置或取得一个人的信息

```java
public interface PersonBean {
	String getName();
	String getGender();
	String getInterests();
	int getHotorNotRating();
	void setName(string name);
	void setGender(String gender);
	void setInterests(string interests);
	void setHotOrNotRating(int rating);
}
```

PersonBean的实现

```java
public class PersonBeanImpl implements PersonBean {
	String name;
	String gender;
	String interests;
	int rating;
	int ratingCount = 0;
	
	public string getName () {
		return name;
	}
	
	public String getGender() {
		return gender;
	}
	
	public String getInterests() {
		return interests;
	}
	
	public int getHotorNotRating(){
		if(ratingCount == 0)
			return 0;
		return (rating/ratingcount);
	}
	
	public void setName(String name){
		this.name = name;
	}
	
	public void setGender(string gender) {
		this.gender = gender;
	}
	
	public void setInterests(string interests) {
		this.interests = interests;
	}
	
	public void setHotOrNotRating(int rating) {
		this.rating+=rating;
		ratingcount++;
	}
}
```

但是现在的问题是任何客户都可以调用任何方法，我们需要一种根据访问权限决定客户是否访问对象的代理。

步骤一：创建InvocationHandler

我们知道需要写两个Invocation Handler（调用处理器），其中一个给拥有者使用，另一个给非拥有者使用。当代理的方法被调用时，代理就会把这个调用转发绐InvocationHandler，但是这并不是通过调用InvocationHandler的相应方法做到的。

```java
interface OwnerInvocationHandler{
	invoke();
}
```

这里有一个名为invoke()的方法，不管代理被调用的是何种方法，处理器被调用的一定是invoke()方法，下面是具体的工作实现：

1. 当proxy的setHotOrNotRating()方法被调用

```java
proxy.setHotOrNotRating(9);
```

2. proxy会接着调用InvocationHandler的invoke()方法

```java
invoke(Object proxy,Methed methed,Object[] args);
```

3. handler决定要如何处置这个请求，可能会转发给RealSubject，handler是如何决定的我们之后就会看到。

```java
return method.invoke(person,args);//我们调用原始proxy被调用的方法，这个对象在调用时被传给我们。只不过加载调用的是真正的主题，person是被调用的对象，args是使用原始的变量
```

继续创建InvocationHandler

当proxy调用invoke()时，要如何应对？通常，你会先检查该方法是否来自proxy，并基于该方法的名称和变量做决定。现在我们就来实现OwnerInvocationHandler，以了解工作机制

```java
import java.lang.reflect.*;//InvocationHandler是java.lang.reflect包的一部分

//所有调用处理器都实现InvocationHandler接口
public class OwnerInvocationHandler implements InvocationHandler {
	PersonBean person;
    
    //将person传入构造器，并保持他的引用
	public ownerInvocationHandler(PersonBean person) {
		this.Person=person;
    }
    
    //每次proxy的方法被调用，就会导致proxy调用此方法
	public object invoke (Object proxy, Method method, object[] args) throws IllegalAccessException {
		
        try{
            //如果该方法是一个getter，我们就调用person内的方法
            if (method.getName().startswith("get")) {
				return method.invoke(person, args);
            }
            //如果是这个方法，我们抛出这个异常表示不允许
			else if (method. getName().equals("setHotorNotRating")){
				IllegalAccessException();
            }
            //因为我们是拥有者，所以任何其他的set方法都可以，我们就在真正主题上调用它
			else if (method.getName().startswith("set") {
				return method.invoke(person, args);
            }
		//真正主题抛出异常的话，就会运行下面的方法
        } catch (InvocationTargetException e) {
			e.printstackTrace();
        }
		return null;
	}
}
```

步骤二：创建Proxy类并实例化Proxy对象

现在，只剩下创建动态Proxy类，并实例化Proxy对象了。让我们开始编写一个以PersonBean为参数，并知道如何为PersonBean对象创建拥有者代理的方法。也就是说，我们要创建一个代理，将它的方法调用转发给OwnerInvocationHandler.代码如下：

```java
//此方法需要一个person对象作为参数，然后返回它的代理，因为代理和主题有相同的接口，所以我们返回一个PersonBean
PersonBean getOwnerProxy(PersonBean person) {
    //利用Proxy类的静态newProxyInstance方法创建代理
	return (PersonBean) Proxy.newProxyInstance(
	person.getclass().getclassLoader(),//将personBean的类载入器作为参数
	person.getclass().getInterfaces(),//代理需要实现的接口
	new OwnerInvocationHandler(person));//调用处理器，将person传入调用处理器的构造器中，这就是之前代码处理器能够访问真实主题的原因
}
```

测试配对服务

```java
public class MatchMakingTestDrive {
	
	public static void main(String[] args) {
		MatchMakingTestDrive test = new MatchMakingTestDrive();
		test.drive();
    }

	public MatchMakingTestDrive {
		initializeDatabase();//初始化服务人员数据库
    }

	public void drive() {
		PersonBean joe = getPersonFromDatabase("Joe Javabean");
		PersonBean ownerProxy = getOwnerProxy (joe);//创建一个拥有者代理
		System.out.println("Name is"+ ownerProxy.getName());//调用getter
		ownerProxy.setInterests("bowling,Go");//调用setter
		System.out.printIn("Interests set from owner proxy");
		try {
			ownerProxy.etHotorNotRating(10);//试着改变评分（行不通）
        }
		catch (Exception e) {
			System.out.println("Can't set rating from owner proxy");
        }
		System.out.printIn("Rating is"+ownerProxy.getHotorNotRating());
		
        PersonBean nonOwnerProxy = getNonownerProxy(joe);
		System.out.println("Name is " + nonOwnweProxy.getName());
		try {
			onOwnerProxy setInterests("bowling, Go");//调用setter（行不通）
        }
		catch (Exception e) {
			System.out.println("Can't set interests from non owner proxy");
        }
        
		nonownerProxy.setHotorNotRating(3);//试着改变评分（行得通）
		System.out.println("Rating set from non owner");
		System.out.println("Rating is "+nonownergroxy.getHotorNotRating());
	}
    //这里还有其他方法，像getOwnerProxy和getNonOwnerProxy
}
```

执行结果

```
% java MatchMakingTestDrive
//OwnerProxy允许getter和setter，但是不允许改变HotOrNot评分
Name is Joe Javabean
Interests set from owner proxy
Cant set rating from owner proxy
Rating is 7

//NonOwnerProxy只允许setter和改变HotOrNot评分，但不允许改变setter
Name is Joe Javabean
Can't set interests from non owner proxy
Rating set from non owner proxy
Rating is 5
%
```

动态代理之所以被称为动态，是因为在运行时才将它的类创建出来。代码开始执行时，还没有Proxy类，他是根据需要从你传入的接口集创建的。

InvocationHandler类是一个帮助proxy的类，proxy会把调用转发给它处理，Proxy本身是利用静态的Proxy.newProxyInstance()方法在运行时动态的创建的。

