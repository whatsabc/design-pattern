## 8 模板方法模式

现在有两个咖啡和茶的类

咖啡类

```
public class coffee {
	void prepareRecipe() {
		boilWater();
		brewcoffeeGrinds();
		pourInCup();
		addSugarAndMilk();
	}
	
	public void boilWater() {
		System. out. println("Boiling water");
	}

	public void brewcoffeeGrinds() {
		system.out.println("Dripping Coffee through filter");
	}

	blic void pourInCup() {
		System. out. println("Pouring into cup");
	}

	public void addsugarAndMilk() {
		System.out.println("Adding Sugar and Milk");
	}
}
```

茶

```
public class Tea {
	void prepareRecipe() {
		soilwater();
		//下面这两个方法是泡茶专有的
		steepTeaBag ();
		pourIncup();
		eddLemon();
	}
	public void boilWater() {
		System. out. println("Boiling water);
	}
	
	public void steepTeaBag() {
		System. out. println("Steeping the tea");
	}

	public void addLemon() {
		System. out. println("Adding Lemon");
	}

	public void pourIncup() {
		System. out. println("Pouring into cup");
	}
}
```

观察上面两个类，我们发现咖啡和茶有很多共同点，两份冲泡法都采用了相同的算法

- 把水煮沸
- 用热水泡咖啡或茶
- 把饮料倒进杯子
- 在饮料内加入适当的调料

其中第二点和第四点并没有被抽象出来，但是它们是一样的，只是用在了不同的饮料上，其他两个方法可以被抽象出来放在基类中

现在，我们抽象一个prepareRecipe()方法

```java
void prepareRecipe() {
	boilWater();
	brew();
	pourInCup();
	addCondiments();
}
```

有了新的方法后，我们再构造一个CaffeinBerverage超类：

```java
//抽象类，用作基类，子类必须实现其操作
public abstract class CaffeineBeverage {
    //模板方法，被声明为final，因为我们不希望子类覆盖这个方法
	final void prepareRecipe() {
        //模板方法定义了一连串的步骤，每个步骤由一个方法代表
		soilWater();
		brew();
		pourInCup();
		addCondiments();
	}
    
    //下面两个方法被声明为抽象，子类必须去实现它
	abstract void brew();

	abstract void addcondiments();

	void soilWater() {
		System.out.println("Boiling water");
	}
	void pourInCup() {
		System.out.println("pouring into cup");
	}
}
```

最后，我们实现咖啡和茶，这两个都依赖我们的咖啡因超类

```java
public class Tea extends CaffeineBeverage {
	public void brew() {
		System.out.println("Steeping the tea");
	}
	public void addcondiments() {
		System.out.printIn("Adding Lemon");
	}
}
```

```java
public class Coffee extends CaffeineBeverage {
	public void brew() {
		System.out.println("Dripping Coffee through filter");
	}
	public void addcondiments() {
		System.out.println("Adding Sugar and Milk");
	}
}
```

基本上，我们上面实现了模板方法模式。比如咖啡因类包含了实际的模板方法

```java
public abstract class CaffeineBeverage {
	void final prepareRecipe() {
		boilWater();
		brew();
		pourInCup();
		addCondiments();
	}
	
	abstract void brew();
	abstract void addCondiments();
	
	void boilWater(){
		//实现
	}
	void pourInCup() {
		//实现
	}
}
```

模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。

现在实例化一个茶对象：

1. 需要一个茶对象

```
Tea myTea = new Tea();
```

2. 然后我们调用这个模板方法：

```
myTea.prepareRecipe();
```

3. 把水煮沸

```
boilWater();
```

这件事情是在咖啡因饮料中进行的

4. 接下来，我们需要泡茶，这件事情只有子类才知道要怎么做

```
brew();
```

5. 现在把茶倒进杯子中，所有饮料做法都一样，所以这件事情发生在超类中：

```
pourInCup();
```

6. 最后，我们加进调料，这个由子类实现

```
addCondiments();
```

> 模板方法模式
>
> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

模板就是一个方法，更具体地说，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现。这样可以确保算法的结构保持不变，同时由子类提供部分实现。

#### 实现钩子

钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。钩子有好几种用途，让我们先看其中稍后再看其他几个

```java
public abstract class caffeineBeveragewithHook {
	void prepareRecipe() {
		soilwater();
		brew();
		pourInCup();
		if (customerWantsCondiments()) {
			addCondiments();
		}
	}
	
	abstract void brew();
	abstract void addCondiments();

	void soilWater() {
		System.out.println("Boiling water");
	}

	void pourIncup() {
		System.out.println("Pouring into cup");
	}
    //这就是一个钩子，子类可以覆盖这个方法，但不一定要这么做
	boolean customerWantsCondiments () {
		return true;
	}
}
```

使用钩子

为了使用钩子，我们需要在子类中覆盖他，在这里，钩子决定了饮料中是否要加进调料

```java
public class CoffeewithHook extends CaffeineBeverageWithHook {
	public void brew() {
		System.out.println("Dripping Coffee through filter");
	}

	public void addCondiments() {
		System.out.println("Adding Sugar and Milk");
	}

	public boolean customer Wantscondiments() {
		String answer = getUserInput();
		
		if (answer.toLowerCase().startswith("y")){
			return true;
		} else {
			return false;
		}
	}

	private string getUserInput() {
		string answer=null;
		System.out.print("Would you like milk and sugar with your coffee(y/n)?");
		BufferedReaderder in = new BufferReader(new InputStreamReader(System.in));
		try{
			answer=in.readLine();
		} catch (IOException ioe) {
			System.err.println("IO error trying to read your answer");
		if(answer == null){
			return "no";
		}
		return answer;
	}
}
```

执行测试程序

```java
public class BeverageTestDrive {
	public static void main(String [] args) {
		TeawithHook teaHook = new TeawithHook();
		CoffeewithHook coffeeHook= new CoffeewithHook();
		
		System.out.println("\nMaking tea...");
		teaHook.prepareRecipe ();
		
		System.out.println("\nMaking coffee.");
		coffeeHook.prepareRecipe();
	}
}
```
